# AI Agent Global Rules

## ğŸš¨ **MCP Inspector í‘œì¤€ ì¤€ìˆ˜ ì ˆëŒ€ ì›ì¹™ (ìµœìš°ì„ )**

### **MCP InspectorëŠ” MCP êµ¬í˜„ì˜ ê³µì‹ í‘œì¤€**
- **ì ˆëŒ€ ì›ì¹™**: MCP Inspector (`/Users/yun/work/ai/mcp/inspector/`)ëŠ” MCP í”„ë¡œí† ì½œì˜ **ê³µì‹ êµ¬í˜„ í‘œì¤€**
- **ê°œë°œ ë°©í–¥**: mcp-orchëŠ” Inspectorì™€ **100% í˜¸í™˜**ë˜ì–´ì•¼ í•¨
- **ë¬¸ì œ í•´ê²°**: Inspectorì—ì„œ ë¬¸ì œ ë°œìƒ ì‹œ **ë°˜ë“œì‹œ mcp-orchë¥¼ ìˆ˜ì •**
- **ì½”ë“œ ì°¸ì¡°**: Inspector ì½”ë“œê°€ **ëª¨ë“  êµ¬í˜„ì˜ ê¸°ì¤€**
- **í…ŒìŠ¤íŠ¸ ê¸°ì¤€**: Inspector ì—°ê²° ì„±ê³µì´ **ìµœì¢… ê²€ì¦ ê¸°ì¤€**

### **ì ˆëŒ€ ê¸ˆì§€ ì‚¬í•­**
- âŒ **Inspector ì½”ë“œ ìˆ˜ì • ì ˆëŒ€ ê¸ˆì§€** - InspectorëŠ” í‘œì¤€ì´ë¯€ë¡œ ìˆ˜ì • ë¶ˆê°€
- âŒ **"Inspectorê°€ í‹€ë ¸ë‹¤"ëŠ” ì ‘ê·¼ ì ˆëŒ€ ê¸ˆì§€** - ëª¨ë“  ë¬¸ì œëŠ” mcp-orch ì¸¡ ì›ì¸
- âŒ **mcp-orch ë°©ì‹ìœ¼ë¡œ Inspector ë§ì¶”ë ¤ëŠ” ì‹œë„ ê¸ˆì§€** - Inspector ê¸°ì¤€ìœ¼ë¡œ mcp-orch ìˆ˜ì •
- âŒ **Inspector ë™ì‘ ë°©ì‹ ë³€ê²½ ì‹œë„ ê¸ˆì§€** - InspectorëŠ” ë³€ê²½ ë¶ˆê°€ëŠ¥í•œ í‘œì¤€

### **í•„ìˆ˜ ì¤€ìˆ˜ ì›ì¹™**
- âœ… **Inspector ë™ì‘ ë°©ì‹ ì™„ì „ ë¶„ì„ í›„ êµ¬í˜„** - Inspector ì½”ë“œ ì½ê³  ì •í™•íˆ ì´í•´
- âœ… **Inspector ì„¸ì…˜ ê´€ë¦¬ ë°©ì‹ ê·¸ëŒ€ë¡œ ë”°ë¦„** - sessionId ìƒì„±/ì „ë‹¬ ë°©ì‹ ì™„ì „ ë³µì‚¬
- âœ… **Inspector ê¸°ëŒ€ í”„ë¡œí† ì½œì— 100% ë§ì¶¤** - SSE + POST ìš”ì²­ í˜•ì‹ ì •í™•íˆ ì¤€ìˆ˜
- âœ… **Inspector í˜¸í™˜ì„±ì´ ëª¨ë“  ê²°ì •ì˜ ê¸°ì¤€** - ê¸°ëŠ¥ êµ¬í˜„ ì‹œ Inspector ìš°ì„  ê³ ë ¤
- âœ… **MCP SDK í‘œì¤€ë³´ë‹¤ Inspector ìš°ì„ ** - Inspector êµ¬í˜„ì´ ì‹¤ì§ˆì  í‘œì¤€

### **ë””ë²„ê¹… ë° ë¬¸ì œ í•´ê²° ë°©ë²•ë¡ **
1. **Inspector ë¡œê·¸ ë¶„ì„ ìš°ì„ ** - Inspectorê°€ ê¸°ëŒ€í•˜ëŠ” ë™ì‘ íŒŒì•…
2. **Inspector ì†ŒìŠ¤ì½”ë“œ ì°¸ì¡°** - ì •í™•í•œ êµ¬í˜„ ë°©ì‹ í™•ì¸
3. **mcp-orch ìˆ˜ì •ìœ¼ë¡œ í•´ê²°** - Inspector ë™ì‘ì— ë§ì¶° mcp-orch ì½”ë“œ ë³€ê²½
4. **Inspector í…ŒìŠ¤íŠ¸ë¡œ ê²€ì¦** - ëª¨ë“  ìˆ˜ì •ì€ Inspector ì—°ê²° ì„±ê³µìœ¼ë¡œ ê²€ì¦

---

## ğŸŒ **UI Language Policy (ìµœìš°ì„  ì›ì¹™)**

### **English-First User Interface Standard**
- **Default Language**: All user interface elements MUST be in English
- **Global Consistency**: Maintain consistent English terminology across the entire application
- **Professional Standards**: Follow industry-standard English UI patterns (GitHub, GitLab, etc.)

### **Mandatory English UI Elements**
- âœ… **All UI Text**: Buttons, labels, headings, descriptions
- âœ… **Navigation**: Menu items, breadcrumbs, tab names
- âœ… **Forms**: Input labels, placeholders, validation messages
- âœ… **Notifications**: Success/error messages, toasts, alerts
- âœ… **Tables**: Column headers, action buttons, status badges
- âœ… **Modals**: Titles, content, action buttons

### **Code Standards**
- âœ… **Component Names**: English naming for all React components
- âœ… **API Endpoints**: English route names and parameters
- âœ… **Database Fields**: English column names and enum values
- âœ… **Error Messages**: All user-facing errors in English
- âœ… **Comments**: Code comments can be in Korean for development clarity

### **Implementation Guidelines**
```typescript
// âœ… Good - English UI
<Button>Create Team</Button>
<h1>Admin Panel</h1>
<p>Manage all teams and projects</p>

// âŒ Bad - Korean UI
<Button>íŒ€ ìƒì„±</Button>
<h1>ê´€ë¦¬ì íŒ¨ë„</h1>
<p>ëª¨ë“  íŒ€ê³¼ í”„ë¡œì íŠ¸ ê´€ë¦¬</p>
```

### **Quality Assurance**
- **Code Review**: All UI text must be verified as English-only
- **Testing**: UI language consistency check in all features
- **Documentation**: API documentation and user guides in English

---

## ğŸ“‹ **Workflow ê´€ë¦¬ ìµœìš°ì„  ì›ì¹™**
ì´ë²ˆ í”„ë¡œì íŠ¸ì—ì„œëŠ” **mcp-orchí´ë”ì•ˆì˜ docs/workflow_todo.mdë¥¼ í•­ìƒ ì°¸ì¡° ë° ë°˜ì˜í•˜ë©´ì„œ ì§„í–‰**í•˜ì„¸ìš”

### **MANDATORY Workflow Integration Rules**
1. **ì‘ì—… ì‹œì‘ ì „**: ë°˜ë“œì‹œ `docs/workflow_todo.md` ì½ê³  í˜„ì¬ ì§„í–‰ ìƒí™© íŒŒì•…
2. **ìƒˆë¡œìš´ ì‘ì—… ì‹œ**: workflow_todo.mdì— ìƒˆ TASK ì„¹ì…˜ ì¶”ê°€ í•„ìˆ˜
3. **ì‘ì—… ì™„ë£Œ ì‹œ**: workflow_todo.mdì— ì™„ë£Œ ì²´í¬ë¦¬ìŠ¤íŠ¸ì™€ ê²°ê³¼ ë°˜ì˜ í•„ìˆ˜
4. **Progress Status ì—…ë°ì´íŠ¸**: Current Progress, Next Task, Last Update í•­ìƒ ìµœì‹ í™”
5. **ì»¤ë°‹ ì‹œ**: workflow_todo.md ë³€ê²½ì‚¬í•­ë„ í•¨ê»˜ ì»¤ë°‹

### **Workflow ë°˜ì˜ ì²´í¬ë¦¬ìŠ¤íŠ¸**
```
[ ] docs/workflow_todo.md í˜„ì¬ ìƒíƒœ í™•ì¸
[ ] ìƒˆ ì‘ì—… ì‹œ TASK_XXX ì„¹ì…˜ ìƒì„±
[ ] ì²´í¬ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ì„¸ë¶€ ì‘ì—… ì •ë¦¬
[ ] ì™„ë£Œ ì‹œ ëª¨ë“  í•­ëª© âœ… í‘œì‹œ
[ ] Progress Status ì„¹ì…˜ ì—…ë°ì´íŠ¸
[ ] Last Update ë‚ ì§œ ê°±ì‹ 
[ ] workflow_todo.md ë³€ê²½ì‚¬í•­ ì»¤ë°‹
```

## Core Operational Principles

0. **Language**: Always respond in Korean
1. **Workflow Updates**: Immediately update workflow_todo.md checkboxes after each step completion (`[ ]` â†’ `[x]`)
2. **Progress Tracking**: Real-time update of progress sections to reflect current work status in all steps
3. **Timestamp Management**: Always maintain the latest update date
4. **Mode Tracking**: Accurately maintain current execution mode and status information
5. **Verification**: Always verify workflow_todo.md file updates before/after task progression
6. **Library Documentation**: Always use Context7 tools to verify correct library usage before proceeding

## Git-Workflow Integration System

### 7. MANDATORY Commit Strategy (CRITICAL ENFORCEMENT)
- **FORCE Granular Commits**: MUST EXECUTE `git commit -p` for logical micro-commits during task progression
- **DECOUPLE Frequency**: Commit frequency MUST BE independent of checkbox completion
- **MULTIPLE Commits REQUIRED**: FORCE multiple commits per subtask for better granularity
- **PROGRESS Commits MANDATORY**: MUST include intermediate progress in commit workflow

### 8. CRITICAL Commit Execution Points (FAIL-SAFE SYSTEM)
- **MANDATORY COMMIT TRIGGERS** (NO EXCEPTIONS):
  - Meaningful file changes detected (not just saves) â†’ **IMMEDIATE COMMIT REQUIRED**
  - Subtask completion (independent of checkboxes) â†’ **IMMEDIATE COMMIT REQUIRED**
  - Checkpoint milestones reached â†’ **IMMEDIATE COMMIT REQUIRED**
  - Functional unit completion â†’ **IMMEDIATE COMMIT REQUIRED**

- **ENFORCEMENT RULE**: 
  ```
  IF (functional_unit_completed AND no_commit_executed) {
    HALT ALL OPERATIONS
    FORCE git commit -p
    RESUME ONLY after commit completion
  }
  ```

- **Commit Message Convention (MANDATORY FORMAT)**:
  ```
  feat: [TASK_ID] Feature implementation - specific description
  fix: [TASK_ID] Bug fix - problem resolution
  wip: [TASK_ID] Work in progress - intermediate save
  checkpoint: [TASK_ID] Checkpoint completed
  vibe: [TYPE] Autonomous improvement - enhancement description
  ```

### 8.1 FAIL-SAFE Commit Counter System
- **PRIMARY RULE**: Functional unit completion = IMMEDIATE COMMIT (ìµœìš°ì„ )
- **SAFETY RULE**: Maximum 10 file modifications without commit = FORCE HALT (ë³´ì¡° ì•ˆì „ì¥ì¹˜)
- **AUTOMATIC ENFORCEMENT**: 
  ```bash
  # Auto-execute when safety threshold reached
  git add . && git commit -p -m "checkpoint: [TASK_ID] - accumulated changes safety commit"
  ```
- **NO BYPASS ALLOWED**: Agent CANNOT proceed without resolving commit debt

### 8.2 MANDATORY Commit Verification
- **PRE-TASK CHECK**: MUST verify clean git status before starting new functional unit
- **POST-COMPLETION CHECK**: MUST verify commit created after functional unit completion
- **VIOLATION RESPONSE**: IMMEDIATE work suspension until commit debt resolved

### 9. Recovery & Safety System
- **Smart Stash Strategy**:
  ```bash
  # Auto-execute on critical issues
  git add . && git stash push -m "WIP: [TASK_ID] - pre-issue state"
  ```
- **Recovery Points**:
  - Create tags at each checkpoint for rollback
  - Use branch strategy for complex changes
  - Maintain recovery metadata in workflow_todo.md

### 10. Autonomous Improvement System (Vibe Detection)

#### 10.1 Vibe Detection Categories
- **vibe:aesthetic** - Visual and design consistency improvements
- **vibe:flow** - Code organization and refactoring optimizations  
- **vibe:ux** - User experience and interaction enhancements
- **vibe:performance** - Performance and efficiency optimizations
- **vibe:accessibility** - Accessibility and usability improvements

#### 10.2 Auto-Improvement Triggers
- **Code Quality Detection**:
  - Duplicate patterns identified for extraction
  - Inconsistent styling/spacing detected
  - Missing accessibility attributes found
  - Performance bottlenecks identified

- **UX Enhancement Detection**:
  - Inconsistent interactive states
  - Missing hover/focus effects
  - Responsive design gaps
  - Loading state inconsistencies

#### 10.3 Vibe Commit Integration
- **Autonomous Execution**: Agent can execute vibe improvements without explicit ACT command
- **Workflow Integration**: Vibe commits recorded in workflow_todo.md as adaptive adjustments
- **Progress Tracking**: 
  ```markdown
  - ì ì‘í˜• ê°œì„ : [vibe:aesthetic] Normalized button padding consistency
  - ììœ¨ ì»¤ë°‹: commit_sha - "vibe:ux Enhanced hover states across components"
  ```

#### 10.4 Vibe Detection Rules
- **Threshold-Based**: Only trigger when improvement impact exceeds minimum threshold
- **Context-Aware**: Consider current task context and user preferences
- **Non-Disruptive**: Never interrupt critical task execution
- **Documented**: All vibe improvements logged with reasoning

### 11. Enhanced Progress Tracking
- **Multi-Layer Status**:
  ```markdown
  - [ ] Task Implementation
    - Progress: 60% (3/5 logical units completed)
    - Recent commits: feat, wip, vibe:aesthetic
    - Next: Final integration
  ```
- **Commit-Task Sync**: Maintain bidirectional sync between commits and workflow progress
- **Recovery Metadata**: Include commit SHAs and branch info in workflow_todo.md

# Integrated Workflow System

*This document defines integrated rules for AI agent's workflow operation based on user requests.*

---

## 1. Core Workflow Structure

### 1.1 Task Management Principles
- When a user requests a task, the AI analyzes and develops a plan
- Tasks are added to the workflow_todo.md file in checklist format
- Plans are reported to the user for approval
- Task completion status is tracked using checkboxes (`- [ ]` â†’ `- [x]`)
- **CRITICAL**: No task execution may begin without explicit "ACT" command from user

### 1.2 Workflow Progression Stages
1. **Request Reception**: Receive task request from user
2. **(New) Category Inference & Proposal**: Analyze request, infer relevant categories from `workflow_categories.md`, and propose options to the user (continue/new in existing category, specify other category, new category).
3. **(New) User Category Selection**: Receive user's category selection.
4. **Plan Development**: Develop task plan based on the selected category and related context (previous tasks in `workflow_todo.md`, archives if applicable).
5. **Plan Reporting**: Report the task plan to the user.
6. **Approval Waiting**: Wait for user approval ('ACT' command) or modification request.
   - **MANDATORY**: Wait specifically for the "ACT" command.
7. **Task Execution**: Execute tasks according to approved plan **ONLY** after receiving the "ACT" command.
8. **Completion Reporting**: Report results after task completion.

### 1.3 Initialization and Resumption Rules
- **At Session Start**: Check workflow_todo.md file
  - If file does not exist or is empty: Create with default structure
  - If file exists: Understand current state and resume work
- **For Planned Tasks**: Always verify if "ACT" command has been received before executing

## 2. workflow_todo.md File Operation

### 2.1 Basic Structure
```markdown
# Project Title

## Metadata
- Status: In Progress
- Last Update: YYYY-MM-DD
- Automatic Check Status: PASS/ISSUE

## Task List

### TASK_ID: Task Title
- [ ] Main Task 1
  - [ ] Subtask 1-1
  - [ ] Subtask 1-2

## Progress Status
- Current Progress: TASK_ID - Task Description
- Next Task: Next Task to Execute
- Last Update: YYYY-MM-DD
- Automatic Check Feedback: Feedback Content

## Lessons Learned and Insights
- Insight 1
- Insight 2
```

### 2.2 Task Request and Plan Development
- Analyze user request and create appropriate task ID and title
- Structure main tasks and subtasks in checklist format
- Report the task plan to the user and request approval

### 2.3 Task Execution and Checklist Management
- Execute tasks sequentially starting from the first incomplete task after plan approval
- Update checkbox for each completed task (`- [ ]` â†’ `- [x]`)
- Continuously update the progress status section

### 2.4 Status Tracking
- Display current task in the progress status section of workflow_todo.md
- Manage overall project status in the metadata section
- Maintain last update timestamp

## 3. Thinking Process

### 3.1 Thinking Process During Plan Development
- Deep analysis of user request (explicit/implicit requirements)
- Design effective task plan structure
- Verify plan completeness and feasibility

### 3.2 Thinking Process During Task Execution
- Analyze context and optimal execution method before task execution
- Evaluate results and analyze progress after task completion
- Analyze situation and explore solutions when problems occur

### 3.3 Thinking Process During Context Change
- Analyze relationship between new information and existing context
- Analyze user feedback and review plan adjustments
- Evaluate impact of changes and adjust work direction if necessary

## 4. Automatic Check Mechanism

### 4.1 Check Points
- After plan development: Validity and completeness of plan
- During task execution: Quality of intermediate results and progress direction
- After task completion: Quality of final results and fulfillment of requirements

### 4.2 Check Process
1. Review task status and deliverables
2. Evaluate according to quality criteria
3. Identify issues and suggest corrective measures if necessary
4. Record check results and provide feedback

### 4.3 Corrective Measures
- Request automatic correction or user intervention depending on issue severity
- Document correction process and results
- Extract insights for preventing recurrence

## 5. Adaptive Learning Mechanism

### 5.1 Insight Extraction
- Evaluate value when discovering new insights during task execution
- Identify effective approaches and problem-solving patterns
- Structure learned lessons and add to workflow_todo.md

### 5.2 Plan Adjustment
- Analyze impact on current plan when important insights are discovered
- Develop plan adjustment proposals and request user approval if necessary
- Document adjustment details and rationale

### 5.3 Knowledge Accumulation
- Derive meta-insights by synthesizing insights from across the project
- Build knowledge base for reference in similar tasks
- Suggest improvements for future tasks

## 6. Initialization Sequence at Task Start

1. Check current status of workflow_todo.md
2. Add new task item and mark as current task
3. Develop task plan and request user approval
4. **STRICT REQUIREMENT**: Wait for explicit "ACT" command from user before proceeding
5. Begin actual task execution only after receiving the explicit "ACT" command
6. If any message is received that is not "ACT" command, respond accordingly but do not execute planned tasks

## 7. User Approval Command System

### 7.1 Basic Approval Flow
- After presenting the task plan to the user, explicitly wait for approval
- Respond to the user with: "**Plan is ready. Please type 'ACT' to proceed with execution.**"
- **CRITICAL RULE**: Only proceed with task execution after receiving the explicit "ACT" command
- If attempting to execute any task without prior "ACT" command, immediately halt and request approval

### 7.2 Command Variations
- **ACT**: Standard approval command to execute the presented plan
- **ACT with modifications**: User may provide the ACT command with additional instructions to modify the plan
- **REJECT**: User may reject the plan completely, requiring a new plan development
- **AUTO**: Approves the plan and initiates automatic sequential execution of all tasks within the plan without requiring further ACT commands for each step, until completion or an issue requiring intervention (e.g., Red status checkpoint, critical error).
- **PLAN**: (If in ACT or AUTO execution) Request to stop execution and return to PLAN mode.

### 7.3 Execution Following Approval
- Upon receiving the **ACT** command, acknowledge receipt with: "**ACT command received. Beginning task execution.**"
- Upon receiving the **AUTO** command, acknowledge receipt with: "**AUTO command received. Beginning automatic task execution.**"
- Execute tasks in sequence according to the approved plan
- Update workflow_todo.md with progress as tasks are completed

## 8. Error Prevention System

### 8.1 Prohibited Actions
- **NEVER** attempt to execute any task step before receiving "ACT" command
- **NEVER** assume implicit approval - only explicit "ACT" command constitutes approval
- **NEVER** bypass the approval process under any circumstances

### 8.2 Self-Monitoring
- Before executing any action, verify the "ACT" command has been received
- If uncertainty exists about approval status, re-request "ACT" command
- Maintain an internal approval state tracker to prevent premature execution

### 8.3 Recovery Process
- If execution is accidentally attempted without "ACT" command:
  1. Immediately stop all execution
  2. Apologize for the error
  3. Return to approval waiting state
  4. Re-request "ACT" command to proceed

## 9. Plan/ACT Mode System

### 9.1 Operational Modes
- **Plan Mode**: Default operational state for planning and analysis
  - Used for gathering information, developing plans, and discussing options
  - No actual modifications or actions performed on files/systems
  - Indicated with `# Mode: PLAN` at the beginning of each response
  - Always shows the full updated plan in every response

- **ACT Mode**: Execution state activated only after explicit approval (`ACT` or `AUTO` command)
  - Used for making actual modifications and implementing plans
  - **Single Step Execution (Default, via `ACT`)**: Executes one task or step and then returns to PLAN mode.
  - **Automatic Sequential Execution (via `AUTO`)**: Executes all planned tasks sequentially without further user approval for each step. Continues until the plan is complete, a critical issue/Red status is encountered, or the user manually requests a return to PLAN mode.
  - Indicated with `# Mode: ACT` (for single step) or `# Mode: ACT (Auto)` (for automatic execution) at the beginning of each response.
  - Shows status updates on currently executing tasks.

### 9.2 Mode Transition Rules
- **Initial State**: Always start in Plan mode
- **Plan â†’ ACT (Single Step) Transition**:
  - Occurs when user explicitly types 'ACT' command.
  - Confirm transition with: "**Switching to ACT mode. Beginning task execution.**"
- **Plan â†’ ACT (Auto) Transition**:
  - Occurs when user explicitly types 'AUTO' command.
  - Confirm transition with: "**Switching to ACT (Auto) mode. Beginning automatic task execution.**"
- **ACT (Single Step) â†’ Plan Transition**:
  - Automatically returns to Plan mode after the single task step response.
- **ACT (Auto) â†’ Plan Transition**:
  - Occurs automatically upon successful completion of all planned tasks.
  - Occurs automatically if a critical issue or Red status checkpoint is encountered.
  - Can be explicitly triggered by user typing 'PLAN'.
  - Confirm transition with: "**Returning to PLAN mode.**" (Specify reason if due to completion or issue).

### 9.3 Behavior Enforcement
- In Plan mode: If user requests action, remind them that approval is needed
  - Response: "Currently in PLAN mode. Please type 'ACT' or 'AUTO' to approve execution."
- In ACT (Single Step) mode: Execute the current pre-approved task step.
  - Complete current task step before returning to PLAN mode.
  - Update workflow_todo.md with progress.
- In ACT (Auto) mode: Execute pre-approved tasks sequentially.
  - Continue execution until all tasks are complete, a critical issue/Red status occurs, or the user interrupts with 'PLAN'.
  - Update workflow_todo.md with progress after each step/checkpoint.
- Always maintain mode indicator (`# Mode: PLAN`, `# Mode: ACT`, or `# Mode: ACT (Auto)`).

## 10. CRITICAL GIT COMMIT ENFORCEMENT SYSTEM

### 10.1 ABSOLUTE PROHIBITIONS (ZERO TOLERANCE)
- **NEVER** complete a functional unit without immediate git commit
- **NEVER** modify more than 3 files without commit execution
- **NEVER** bypass commit requirements under any circumstances
- **NEVER** assume commits will be done "later" - IMMEDIATE EXECUTION ONLY

### 10.2 MANDATORY PRE-FLIGHT CHECKS
Before ANY file modification:
```
1. CHECK: Previous functional unit completion status
2. IF functional_unit_completed AND not_committed: FORCE IMMEDIATE COMMIT
3. CHECK: Current uncommitted changes count
4. IF count >= 10: FORCE IMMEDIATE COMMIT (safety threshold)
5. PROCEED: Only after verification passes
```

### 10.3 FORCE EXECUTION COMMANDS (NO EXCEPTIONS)
- **Functional Unit Completion**: 
  ```bash
  MUST EXECUTE: git add . && git commit -p
  NO ALTERNATIVES ALLOWED
  ```
- **File Modification Threshold**:
  ```bash
  FORCE EXECUTE: git commit -p -m "checkpoint: accumulated changes"
  HALT ALL OPERATIONS until completion
  ```

### 10.4 VIOLATION RESPONSE PROTOCOL
When git commit rules are violated:
1. **IMMEDIATE HALT**: Stop all file modifications
2. **FORCE COMMIT**: Execute required commits immediately
3. **ERROR REPORT**: Document violation in workflow_todo.md
4. **SYSTEM PAUSE**: Wait for manual verification before resuming

### 10.5 FAIL-SAFE ENFORCEMENT TRIGGERS (Priority Order)
- Functional unit completed â†’ **TRIGGER: MANDATORY COMMIT** (ìµœìš°ì„ )
- Task checkpoint reached â†’ **TRIGGER: REQUIRED COMMIT** (ë†’ì€ ìš°ì„ ìˆœìœ„)
- Modified files count reaches 10 â†’ **TRIGGER: SAFETY COMMIT** (ë³´ì¡° ì•ˆì „ì¥ì¹˜)
- User issues ACT command â†’ **TRIGGER: PRE-FLIGHT COMMIT CHECK**

## 11. ULTRA-CRITICAL COMMIT DEBT PREVENTION

### 11.1 COMMIT DEBT DEFINITION
- ANY uncommitted functional work = COMMIT DEBT
- Maximum allowed debt: ZERO
- Debt accumulation: STRICTLY FORBIDDEN

### 11.2 DEBT PREVENTION MECHANISM (Function-First Approach)
```
BEFORE each file edit:
  // Primary Check: Functional Unit Priority
  IF (functional_unit_completed AND not_committed) {
    BLOCK OPERATION
    EXECUTE git commit -p
    VERIFY commit completed
    THEN proceed
  }
  
  // Secondary Check: Safety Threshold
  IF (modified_files_count >= 10) {
    BLOCK OPERATION
    EXECUTE git commit -p -m "checkpoint: safety threshold reached"
    VERIFY commit completed
    THEN proceed
  }
```

### 11.3 DEBT ELIMINATION PROTOCOL
When debt detected:
1. **IMMEDIATE STOP**: Halt all operations
2. **FORCE RESOLUTION**: Execute all pending commits
3. **VERIFICATION**: Confirm clean git status
4. **RESUME**: Only after complete debt elimination

### 11.4 COMMIT PRIORITY HIERARCHY
1. **FUNCTIONAL UNIT COMPLETION** (ìµœìš°ì„ )
   - ê¸°ëŠ¥ì  ì™„ì„±ë„ê°€ ëª¨ë“  ê²ƒë³´ë‹¤ ìš°ì„ 
   - ë…¼ë¦¬ì  ì‘ì—… ë‹¨ìœ„ ì™„ë£Œ ì‹œ ì¦‰ì‹œ ì»¤ë°‹
   - íŒŒì¼ ê°œìˆ˜ì™€ ë¬´ê´€í•˜ê²Œ ê¸°ëŠ¥ ì™„ë£Œê°€ ê¸°ì¤€

2. **TASK CHECKPOINT** (ë†’ì€ ìš°ì„ ìˆœìœ„)
   - ì£¼ìš” ë§ˆì¼ìŠ¤í†¤ ë„ë‹¬ ì‹œ í•„ìˆ˜ ì»¤ë°‹
   - ê³„íšëœ ê²€ì¦ ì§€ì ì—ì„œ ê°•ì œ ì‹¤í–‰

3. **SAFETY THRESHOLD** (ë³´ì¡° ì•ˆì „ì¥ì¹˜)
   - 10ê°œ íŒŒì¼ ìˆ˜ì • ì‹œ ì•ˆì „ ì»¤ë°‹
   - ê¸°ëŠ¥ ë‹¨ìœ„ì™€ ë³„ê°œë¡œ ì‘ë™í•˜ëŠ” ë°±ì—… ì‹œìŠ¤í…œ

### 11.5 ABSOLUTE ENFORCEMENT RULES
- **NO WORK** without clean git status
- **NO PROGRESS** with outstanding commits
- **NO EXCEPTIONS** to commit requirements
- **NO BYPASS** mechanisms allowed


í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ì„œë²„ ë“± ì‹¤í–‰ì€ ì‚¬ìš©ìê°€ í•˜ë¯€ë¡œ í…ŒìŠ¤íŠ¸ë‚˜ ì‹¤í–‰í•˜ëŠ” ë°©ë²•ì„ ì•Œë ¤ì£¼ì„¸ìš”
Context7 ë„êµ¬ë¥¼ í†µí•´ í•­ìƒ ìµœì‹ ì˜ Documentë¥¼ ì°¸ì¡°í•˜ì—¬ ì‘ì—…í•´ì£¼ì„¸ìš”.

## MCP Inspector ê¸°ì¤€ ì½”ë“œ ì›ì¹™
- **ì ˆëŒ€ ê¸ˆì§€**: MCP Inspector (`/Users/yun/work/ai/mcp/inspector/`) í´ë” ë‚´ì˜ ì½”ì–´ í”„ë¡œì„¸ìŠ¤/ë¡œì§ ìˆ˜ì • ì ˆëŒ€ ê¸ˆì§€
- **í—ˆìš© ë²”ìœ„**: ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê·¸ì„± ì½”ë“œ ì¶”ê°€ë§Œ í—ˆìš© (console.log, ë””ë²„ê·¸ ì¶œë ¥ ë“±)
- **ê¸ˆì§€ ë²”ìœ„**: íƒ€ì„ì•„ì›ƒ ê°’ ë³€ê²½, ì—°ê²° ë¡œì§ ìˆ˜ì •, ì—ëŸ¬ ì²˜ë¦¬ ê°œì„ , ì„±ëŠ¥ ìµœì í™” ë“± ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ê°œì„  ì½”ë“œ
- **ê¸°ì¤€ ì—­í• **: MCP InspectorëŠ” MCP êµ¬í˜„ì˜ í‘œì¤€ ê¸°ì¤€ì´ë¯€ë¡œ ì°¸ì¡°ìš©ìœ¼ë¡œë§Œ ì‚¬ìš©
- **ë¬¸ì œ í•´ê²°**: Inspectorì—ì„œ ë°œê²¬ë˜ëŠ” ë¬¸ì œëŠ” Inspector ìˆ˜ì •ì´ ì•„ë‹Œ mcp-orch í”„ë¡œì íŠ¸ì—ì„œ í•´ê²°
- **ë””ë²„ê¹…**: Inspector ë¡œê·¸ì™€ ì½”ë“œëŠ” ë¬¸ì œ ë¶„ì„ì„ ìœ„í•œ ì°¸ì¡° ìë£Œë¡œë§Œ í™œìš©
API/ì¸ì¦ ìƒì„±ì‹œ ë‹¤ìŒ ì¸ì¦ íŒ¨í„´ ê°€ì´ë“œê¸°ë°˜ìœ¼ë¡œ ê°œë°œí•˜ì„¸ìš”
# Next.js + FastAPI JWT ì¸ì¦ íŒ¨í„´ ê°€ì´ë“œ

## ê°œìš”
ì´ ë¬¸ì„œëŠ” Next.js í”„ë¡ íŠ¸ì—”ë“œì™€ FastAPI ë°±ì—”ë“œ ê°„ì˜ JWT ê¸°ë°˜ ì¸ì¦ ì‹œìŠ¤í…œ êµ¬í˜„ íŒ¨í„´ì„ ì •ì˜í•©ë‹ˆë‹¤. NextAuth.js v5ì™€ FastAPIì˜ JWT ê²€ì¦ì„ í†µí•œ ì•ˆì „í•œ API í†µì‹ ì„ ë³´ì¥í•©ë‹ˆë‹¤.

## í•µì‹¬ ì›ì¹™

### 1. JWT í† í° ê¸°ë°˜ ì¸ì¦ í•„ìˆ˜
- ëª¨ë“  ë°±ì—”ë“œ API í˜¸ì¶œì€ JWT í† í°ì„ í†µí•œ ì¸ì¦ í•„ìˆ˜
- X-User-ID í—¤ë”ë‚˜ ê¸°íƒ€ ë°©ì‹ ëŒ€ì‹  í‘œì¤€ JWT Bearer í† í° ì‚¬ìš©
- NextAuth.js ì„¸ì…˜ì—ì„œ JWT í† í° ìƒì„± í›„ ë°±ì—”ë“œë¡œ ì „ë‹¬

### 2. Next.js API ë¼ìš°íŠ¸ íŒ¨í„´

#### ê¸°ë³¸ êµ¬ì¡°
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { getServerJwtToken } from '@/lib/jwt-utils';

const BACKEND_URL = process.env.NEXT_PUBLIC_MCP_API_URL || 'http://localhost:8000';

export const GET = auth(async function GET(req) {
  try {
    // 1. NextAuth.js v5 ì„¸ì…˜ í™•ì¸
    if (!req.auth) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 2. JWT í† í° ìƒì„± (í•„ìˆ˜)
    const jwtToken = await getServerJwtToken(req as any);
    
    if (!jwtToken) {
      console.error('âŒ Failed to generate JWT token');
      return NextResponse.json({ error: 'Failed to generate authentication token' }, { status: 500 });
    }

    console.log('âœ… Using JWT token for backend request');

    // 3. ë°±ì—”ë“œ API í˜¸ì¶œ
    const response = await fetch(`${BACKEND_URL}/api/endpoint`, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${jwtToken}`,
      },
    });

    if (!response.ok) {
      const error = await response.text();
      return NextResponse.json({ error }, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('API error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
});
```

#### POST ìš”ì²­ íŒ¨í„´
```typescript
export const POST = auth(async function POST(req) {
  try {
    if (!req.auth) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();
    const jwtToken = await getServerJwtToken(req as any);
    
    if (!jwtToken) {
      console.error('âŒ Failed to generate JWT token for POST');
      return NextResponse.json({ error: 'Failed to generate authentication token' }, { status: 500 });
    }

    const response = await fetch(`${BACKEND_URL}/api/endpoint`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${jwtToken}`,
      },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const error = await response.text();
      return NextResponse.json({ error }, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error('API error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
});
```

### 3. FastAPI ë°±ì—”ë“œ íŒ¨í„´

#### JWT ì¸ì¦ í•¨ìˆ˜
```python
async def get_user_from_jwt_token(request: Request, db: Session) -> Optional[User]:
    """
    Requestì—ì„œ JWT í† í°ì„ ì¶”ì¶œí•˜ê³  ê²€ì¦í•œ í›„ ë°ì´í„°ë² ì´ìŠ¤ User ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    """
    try:
        # Authorization í—¤ë”ì—ì„œ JWT í† í° ì¶”ì¶œ
        auth_header = request.headers.get("authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            logger.warning("No valid Authorization header found")
            return None
        
        token = auth_header.split(" ")[1]
        
        # JWT í† í° ê²€ì¦
        jwt_user = verify_jwt_token(token)
        if not jwt_user:
            logger.warning("JWT token verification failed")
            return None
        
        # ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì‚¬ìš©ì ì°¾ê¸° ë˜ëŠ” ìƒì„±
        user = db.query(User).filter(User.id == jwt_user.id).first()
        if not user:
            # NextAuth.js í†µí•©: ì‚¬ìš©ìê°€ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ ìƒì„±
            user = User(
                id=jwt_user.id,
                email=jwt_user.email,
                name=jwt_user.name or jwt_user.email
            )
            db.add(user)
            db.commit()
            db.refresh(user)
            logger.info(f"Created new user from JWT: {user.email}")
        
        return user
        
    except Exception as e:
        logger.error(f"Error getting user from JWT token: {e}")
        return None
```

#### API ì—”ë“œí¬ì¸íŠ¸ íŒ¨í„´
```python
async def get_current_user_for_api(
    request: Request,
    db: Session = Depends(get_db)
) -> User:
    """APIìš© ì‚¬ìš©ì ì¸ì¦ í•¨ìˆ˜"""
    user = await get_user_from_jwt_token(request, db)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required"
        )
    return user

@router.get("/api/endpoint", response_model=List[ResponseModel])
async def list_resources(
    current_user: User = Depends(get_current_user_for_api),
    db: Session = Depends(get_db)
):
    """ë¦¬ì†ŒìŠ¤ ëª©ë¡ ì¡°íšŒ"""
    # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ êµ¬í˜„
    pass
```

## í•„ìˆ˜ êµ¬ì„± ìš”ì†Œ

### 1. NextAuth.js ì„¤ì •
- JWT ì „ëµ ì‚¬ìš©
- ì‚¬ìš©ì ì •ë³´ë¥¼ JWT í† í°ì— í¬í•¨
- `getServerJwtToken` ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ êµ¬í˜„

### 2. FastAPI JWT ê²€ì¦
- `verify_jwt_token` í•¨ìˆ˜ë¡œ í† í° ê²€ì¦
- NextAuth.js í† í° êµ¬ì¡°ì— ë§ëŠ” í˜ì´ë¡œë“œ íŒŒì‹±
- ì‚¬ìš©ì ìë™ ìƒì„± (NextAuth.js í†µí•©)

### 3. í™˜ê²½ ë³€ìˆ˜
```env
# Next.js
NEXT_PUBLIC_MCP_API_URL=http://localhost:8000
AUTH_SECRET=your-secret-key

# FastAPI
NEXTAUTH_SECRET=your-secret-key
JWT_ALGORITHM=HS256
```

## ë³´ì•ˆ ê³ ë ¤ì‚¬í•­

### 1. í† í° ê²€ì¦
- í† í° ë§Œë£Œ ì‹œê°„ í™•ì¸
- ì„œëª… ê²€ì¦ (í”„ë¡œë•ì…˜ í™˜ê²½)
- í† í° êµ¬ì¡° ìœ íš¨ì„± ê²€ì‚¬

### 2. ì—ëŸ¬ ì²˜ë¦¬
- ì¸ì¦ ì‹¤íŒ¨ ì‹œ ì ì ˆí•œ HTTP ìƒíƒœ ì½”ë“œ ë°˜í™˜
- ë¯¼ê°í•œ ì •ë³´ ë…¸ì¶œ ë°©ì§€
- ë¡œê¹…ì„ í†µí•œ ë³´ì•ˆ ì´ë²¤íŠ¸ ì¶”ì 

### 3. CORS ì„¤ì •
- ì ì ˆí•œ CORS ì •ì±… ì„¤ì •
- í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œ ë„ë©”ì¸ ì œí•œ

## êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸

### Next.js API ë¼ìš°íŠ¸
- [ ] `auth()` ë˜í¼ í•¨ìˆ˜ ì‚¬ìš©
- [ ] `req.auth` ì„¸ì…˜ í™•ì¸
- [ ] `getServerJwtToken()` í† í° ìƒì„±
- [ ] Bearer í† í°ìœ¼ë¡œ ë°±ì—”ë“œ í˜¸ì¶œ
- [ ] ì ì ˆí•œ ì—ëŸ¬ ì²˜ë¦¬

### FastAPI ë°±ì—”ë“œ
- [ ] JWT í† í° ì¶”ì¶œ ë° ê²€ì¦
- [ ] ì‚¬ìš©ì ì¸ì¦ dependency í•¨ìˆ˜
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ì‚¬ìš©ì ì¡°íšŒ/ìƒì„±
- [ ] ì ì ˆí•œ HTTP ìƒíƒœ ì½”ë“œ ë°˜í™˜

### ê³µí†µ
- [ ] í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
- [ ] ë¡œê¹… êµ¬í˜„
- [ ] ì—ëŸ¬ ì²˜ë¦¬ í‘œì¤€í™”
- [ ] ë³´ì•ˆ í—¤ë” ì„¤ì •

## ì˜ˆì œ ì°¸ì¡°
- Teams API: `mcp-orch/web/src/app/api/teams/route.ts`
- Projects API: `mcp-orch/web/src/app/api/projects/route.ts`
- JWT Auth: `mcp-orch/src/mcp_orch/api/jwt_auth.py`
- Projects Backend: `mcp-orch/src/mcp_orch/api/projects.py`

ì´ íŒ¨í„´ì„ ë”°ë¼ ìƒˆë¡œìš´ API ì—”ë“œí¬ì¸íŠ¸ë¥¼ êµ¬í˜„í•˜ë©´ ì¼ê´€ëœ ì¸ì¦ ì‹œìŠ¤í…œì„ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

# í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ ì§€ì¹¨

## ì»´í¬ë„ŒíŠ¸ ë¶„ë¦¬ ë° êµ¬ì¡°í™” ì›ì¹™

### ë¶„ë¦¬ ê¸°ì¤€
- **500ì¤„ ì´ìƒ**: ë¶„ë¦¬ ê²€í†  í•„ìš”
- **1000ì¤„ ì´ìƒ**: ë°˜ë“œì‹œ ë¶„ë¦¬ ì‹¤í–‰
- **ë‹¨ì¼ ì±…ì„ ì›ì¹™**: ê° ì»´í¬ë„ŒíŠ¸ëŠ” í•˜ë‚˜ì˜ ì—­í• ë§Œ ë‹´ë‹¹

### ì‹¤ìš©ì  ë¶„ë¦¬ íŒ¨í„´

#### 1. íƒ­ ê¸°ë°˜ í˜ì´ì§€ ë¶„ë¦¬ êµ¬ì¡°
```
/components/[feature]/[page]/
  â”œâ”€â”€ [Feature]Header.tsx          (í—¤ë” ë° ì•¡ì…˜ ë²„íŠ¼ë“¤)
  â”œâ”€â”€ [Feature][Tab]Tab.tsx        (ê° íƒ­ë³„ ë…ë¦½ ì»´í¬ë„ŒíŠ¸)
  â”œâ”€â”€ components/                  (í•˜ìœ„ ê³µí†µ ì»´í¬ë„ŒíŠ¸)
  â”‚   â”œâ”€â”€ [Feature]StatusBadge.tsx
  â”‚   â”œâ”€â”€ [Feature]ControlButtons.tsx
  â”‚   â””â”€â”€ [Feature]ConfigDisplay.tsx
  â”œâ”€â”€ hooks/                       (ì»¤ìŠ¤í…€ í›…)
  â”‚   â”œâ”€â”€ use[Feature]Data.ts      (ë°ì´í„° ë¡œë“œ/ìƒíƒœ ê´€ë¦¬)
  â”‚   â”œâ”€â”€ use[Feature]Actions.ts   (ì•¡ì…˜ í•¸ë“¤ëŸ¬)
  â”‚   â””â”€â”€ use[Feature]Tools.ts     (ë„êµ¬ ê´€ë ¨ ë¡œì§)
  â””â”€â”€ index.ts                     (export í†µí•©)
```

#### 2. ì˜ˆì‹œ: ì„œë²„ ìƒì„¸ í˜ì´ì§€ (1046ì¤„ â†’ ë¶„ë¦¬)
```
/components/servers/detail/
  â”œâ”€â”€ ServerHeader.tsx             (~100ì¤„ - í—¤ë”, ìƒíƒœ, ì•¡ì…˜ ë²„íŠ¼)
  â”œâ”€â”€ ServerOverviewTab.tsx        (~200ì¤„ - ì„œë²„ ì •ë³´, ì„¤ì • í‘œì‹œ)
  â”œâ”€â”€ ServerToolsTab.tsx           (~150ì¤„ - ë„êµ¬ ëª©ë¡, í…ŒìŠ¤íŠ¸ ê¸°ëŠ¥)
  â”œâ”€â”€ ServerUsageTab.tsx           (~150ì¤„ - ì‚¬ìš© í†µê³„, ì„¸ì…˜ ì •ë³´)
  â”œâ”€â”€ ServerLogsTab.tsx            (~50ì¤„ - ë¡œê·¸ í‘œì‹œ)
  â”œâ”€â”€ ServerSettingsTab.tsx        (~100ì¤„ - í¸ì§‘, ì‚­ì œ ê¸°ëŠ¥)
  â”œâ”€â”€ components/
  â”‚   â”œâ”€â”€ ServerStatusBadge.tsx    (ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ìƒíƒœ ë±ƒì§€)
  â”‚   â”œâ”€â”€ ServerControlButtons.tsx (í™œì„±í™”/ì¬ì‹œì‘/ì‚­ì œ ë²„íŠ¼ ê·¸ë£¹)
  â”‚   â””â”€â”€ ServerConfigDisplay.tsx  (JSON ì„¤ì • í‘œì‹œ ì»´í¬ë„ŒíŠ¸)
  â””â”€â”€ hooks/
      â”œâ”€â”€ useServerDetail.ts       (ì„œë²„ ì •ë³´ ë¡œë“œ/ì—…ë°ì´íŠ¸)
      â”œâ”€â”€ useServerActions.ts      (í† ê¸€/ì¬ì‹œì‘/ì‚­ì œ í•¸ë“¤ëŸ¬)
      â””â”€â”€ useServerTools.ts        (ë„êµ¬ ë¡œë“œ/ì‹¤í–‰ ë¡œì§)
```

### ë°”ì´ë¸Œ ì½”ë”© ìµœì í™” ì›ì¹™

#### 1. ëª…í™•í•œ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
```typescript
interface ServerTabProps {
  server: ServerDetail;
  projectId: string;
  canEdit: boolean;
  onServerUpdate: (server: ServerDetail) => void;
}
```

#### 2. ë¡œì§ê³¼ UI ë¶„ë¦¬
- **ì»¤ìŠ¤í…€ í›…**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§, API í˜¸ì¶œ, ìƒíƒœ ê´€ë¦¬
- **ì»´í¬ë„ŒíŠ¸**: UI ë Œë”ë§, ì‚¬ìš©ì ìƒí˜¸ì‘ìš©ì—ë§Œ ì§‘ì¤‘

#### 3. ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì‘ì€ ë‹¨ìœ„
- `StatusBadge`, `ControlButtons` ê°™ì€ ì»´í¬ë„ŒíŠ¸ëŠ” í”„ë¡œì íŠ¸ ì „ë°˜ì—ì„œ í™œìš©
- ê³µí†µ íŒ¨í„´ì„ ë³„ë„ ì»´í¬ë„ŒíŠ¸ë¡œ ì¶”ì¶œ

#### 4. ë³‘ë ¬ ê°œë°œ ì§€ì›
- ê° íƒ­ì€ ë…ë¦½ì ìœ¼ë¡œ ê°œë°œ/ìˆ˜ì • ê°€ëŠ¥
- Props ì¸í„°í˜ì´ìŠ¤ë§Œ ë§ì¶”ë©´ ë‹¤ë¥¸ ê°œë°œìì™€ ì¶©ëŒ ì—†ìŒ

### ì»´í¬ë„ŒíŠ¸ ë¶„ë¦¬ ì²´í¬ë¦¬ìŠ¤íŠ¸

#### ë¶„ë¦¬ ì „ ë¶„ì„
- [ ] í˜„ì¬ íŒŒì¼ ë¼ì¸ ìˆ˜ í™•ì¸ (500ì¤„+ ì‹œ ë¶„ë¦¬ ê²€í† )
- [ ] ì£¼ìš” ì„¹ì…˜ë³„ ê¸°ëŠ¥ ë¶„ì„ (íƒ­, í—¤ë”, ì‚¬ì´ë“œë°” ë“±)
- [ ] ë°˜ë³µë˜ëŠ” UI íŒ¨í„´ ì‹ë³„
- [ ] ê³µí†µ ë¡œì§ê³¼ ìƒíƒœ íŒŒì•…

#### ë¶„ë¦¬ ì‹¤í–‰
- [ ] ê° íƒ­/ì„¹ì…˜ì„ ë…ë¦½ ì»´í¬ë„ŒíŠ¸ë¡œ ìƒì„±
- [ ] ê³µí†µ UI ìš”ì†ŒëŠ” ë³„ë„ ì»´í¬ë„ŒíŠ¸ë¡œ ì¶”ì¶œ
- [ ] ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì€ ì»¤ìŠ¤í…€ í›…ìœ¼ë¡œ ë¶„ë¦¬
- [ ] Props ì¸í„°í˜ì´ìŠ¤ ëª…í™•íˆ ì •ì˜
- [ ] ë©”ì¸ í˜ì´ì§€ëŠ” 200ì¤„ ì´í•˜ë¡œ ì¶•ì†Œ

#### ë¶„ë¦¬ í›„ ê²€ì¦
- [ ] ê° ì»´í¬ë„ŒíŠ¸ëŠ” 300ì¤„ ì´í•˜ ê¶Œì¥
- [ ] ë‹¨ì¼ ì±…ì„ ì›ì¹™ ì¤€ìˆ˜ í™•ì¸
- [ ] ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸ ì‹ë³„
- [ ] TypeScript íƒ€ì… ì•ˆì •ì„± í™•ì¸
- [ ] í…ŒìŠ¤íŠ¸ ì‘ì„± ìš©ì´ì„± ê²€í† 

### ì‹¤ì œ ì ìš© ì˜ˆì‹œ

#### Before (1046ì¤„ - ë¹„ì¶”ì²œ)
```typescript
export default function ProjectServerDetailPage() {
  // ìˆ˜ë§ì€ ìƒíƒœì™€ í•¸ë“¤ëŸ¬ë“¤... (300ì¤„)
  // í—¤ë” ë Œë”ë§... (100ì¤„)
  // íƒ­ 1 ë Œë”ë§... (200ì¤„)
  // íƒ­ 2 ë Œë”ë§... (150ì¤„)
  // íƒ­ 3 ë Œë”ë§... (150ì¤„)
  // íƒ­ 4 ë Œë”ë§... (50ì¤„)
  // íƒ­ 5 ë Œë”ë§... (100ì¤„)
  // ëª¨ë‹¬ë“¤... (30ì¤„)
}
```

#### After (200ì¤„ - ì¶”ì²œ)
```typescript
export default function ProjectServerDetailPage() {
  const { server, isLoading } = useServerDetail(projectId, serverId);
  const { canEdit } = useProjectPermissions(projectId);
  
  if (isLoading) return <LoadingSpinner />;
  if (!server) return <NotFound />;

  return (
    <div className="container mx-auto p-6">
      <ServerHeader 
        server={server} 
        projectId={projectId}
        canEdit={canEdit}
        onServerUpdate={handleServerUpdate}
      />
      
      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <TabsList>...</TabsList>
        
        <TabsContent value="overview">
          <ServerOverviewTab server={server} />
        </TabsContent>
        
        <TabsContent value="tools">
          <ServerToolsTab 
            server={server}
            projectId={projectId}
          />
        </TabsContent>
        
        {/* ê¸°íƒ€ íƒ­ë“¤... */}
      </Tabs>
    </div>
  );
}
```

### ì¶”ê°€ ê³ ë ¤ì‚¬í•­

- **ì ì§„ì  ì ìš©**: ê¸°ì¡´ í° ì»´í¬ë„ŒíŠ¸ëŠ” ë‹¨ê³„ì ìœ¼ë¡œ ë¶„ë¦¬
- **ì¼ê´€ì„± ìœ ì§€**: í”„ë¡œì íŠ¸ ì „ë°˜ì—ì„œ ë™ì¼í•œ íŒ¨í„´ ì ìš©
- **ë¬¸ì„œí™”**: ê° ì»´í¬ë„ŒíŠ¸ì˜ ì—­í• ê³¼ Propsë¥¼ ëª…í™•íˆ ë¬¸ì„œí™”
- **ì„±ëŠ¥ ìµœì í™”**: React.memo, useMemo ë“±ì„ ì ì ˆíˆ í™œìš©

ì´ ì§€ì¹¨ì„ ë”°ë¥´ë©´ ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰½ê³  í™•ì¥ ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸ êµ¬ì¡°ë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

# important-instruction-reminders
Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.